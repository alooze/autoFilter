___AutoFilter для MODX Evo___

Больше подробностей см. http://af.div.net.ua

********************************************************
_Описание_
********************************************************

Расширение autoFilter предназначено для создания форм фильтрации элементов каталога. Такими элементами могут являться документы MODX, товары в таблице shopkeeper или вообще любые данные из любых таблиц. Однако, по умолчанию, обычная версия autoFilter работает только с документами MODX (см. параметр &mode).


В данной версии фильтры работают в "жадном" режиме. Т.е. при указании значений в форме фильтрации будут показаны только те товары (элементы каталога), которые удовлетворяют всем значениям фильтров. Если нужна логика "удовлетворяет хотя бы одному из указанных значений фильтров" ("нежадный" режим), ее нужно будет реализовывать отдельно.

********************************************************
_Параметры_
********************************************************

__Вызов сниппета__

&id - id вызова сниппета (в случае нескольких вызовов на странице); плейсхолдеры в этом случае нужно будет использовать с префиксом не af, а с таким же, как id. Например, &id=`my`, плейсхолдеры нужно будет писать в виде [+my.PLACEHOLDER+]. По умолчанию &id=`af`

&path - путь к файлам сниппета. По умолчанию &path=`assets/snippets/autoFilter/`

&config - чанк или файл, с настройками фильтрации. По умолчанию используется файл assets/snippets/autoFilter/config.inc.txt, указывать его не нужно. Синтаксис: &config=`@FILE ПУТЬ_К_ФАЙЛУ` или &config=`НАЗВАНИЕ_ЧАНКА_С_НАСТРОЙКАМИ` В данной версии используется только частично.

&mode - режим работы сниппета. В данной версии частично заменяет собой параметр &config и в дальнейшем скорее всего будет удален. По умолчанию &mode=`base`, что означает: все категории и товары (э.к.) являются документами modx, а все опции (кроме pagetitle и некоторых других) хранятся в TV. Другие режимы пока не будут реализованы.


__Входящие данные__

&parents - список папок в дереве modx, разделенный запятыми. Товары (элементы каталога) будут искаться в этих папках. По умолчанию - &parents=`0` (искать во всех документах) (?)

&itemIds - дополняет или заменяет &afparents. Разделенный запятой список непосредственно товаров (э.к.). Это могут быть как документы modx, так и данные в сторонних таблицах. По умолчанию - пусто. Если есть список товаров, фильтрация будет произведена только среди этих товаров.

&skipFolders - пропускать подпапки при сканировании папок из параметра &afparents. По умолчанию &skipFolders=`1`, папки не сканируются. Этот параметр можно использовать, если категории товаров (э.к.) сделаны в виде вложенных папок в дереве modx и эти документы-категории не являются товарами.

&includeTv - формировать фильтры с учетом только перечисленных TV ID.  Разделенный запятой список TV ID. По умолчанию - пусто
&excludeTv - формировать фильтры, не учитывая перечисленные TV ID.  Разделенный запятой список TV ID. По умолчанию - пусто

[ ! ] Две опции выше имеют в названии "TV" только для наглядности. В случае фильтрации данных из сторонних таблиц, опции фильтрации могут храниться в собственных таблицах.

&preFilter - строка, задающая начальные установки фильтра при первой загрузке формы фильтрации. Используется, например, в случае, когда создаются отдельные "посадочные" страницы, на которых уже отфильтрованы некоторые товары (э.к.). В этом случае, форму фильтрации можно вообще не показывать (см. параметр &showForm). Уместно задавать в вызове сниппета значение этого параметра с помощью специально созданного TV. Тогда параметр будет выглядеть так: &preFilter=`[*_prefilter_TV_*]`, а сами значения предфильтров можно будет устанавливать при создании документа modx (если назначить шаблону таких "посадочных" страниц текстовую TV с именем "_prefilter_TV_", как в примере). Синтаксис предфильтра описан ниже.

[ ? ] Формат задания пред-фильтров:
    НАЗВАНИЕ ПОЛЯ В ФОРМЕ:ЗНАЧЕНИЯ (ДЛЯ МАССИВА - ЧЕРЕЗ ЗАПЯТУЮ) ДЛЯ ПОДСТАНОВКИ
    разделитель - "|"
    например: в форме есть поля
    <input type="checkbox" value="46" name="boo[]"/>
    <input type="checkbox" value="47" name="boo[]"/>
    <input type="checkbox" value="48" name="boo[]"/>
    чтобы отметить все поля, пишем:
    "boo:46,47,48" (установит $_REQUEST['boo'][0]=46,$_REQUEST['boo'][1]=47,$_REQUEST['boo'][2]=48)
    чтобы отметить только второй и третий:
    "boo:47,48" (установит $_REQUEST['boo'][0]=47,$_REQUEST['boo'][1]=48)
    чтобы отметить только первый:
    "boo:46," (установит $_REQUEST['boo'][0]=46)
    НО
    "boo:46" установит $_REQUEST['boo']=46 (т.е. запятая в значениях - признак массива)


__Вывод результатов работы сниппета__

&showForm - нужно ли показывать саму форму фильтрации на данной странице. По умолчанию &showForm=`1`

&afShowResultOnRun - нужно ли при первой загрузке формы показывать результаты работы сниппета вывода (Ditto или другого). По умолчанию &afShowResultOnRun=`1`, т.е. при первой загрузке страницы с формой будет выводиться результат работы сниппета вывода с пустыми фильтрами (весь набор товаров). Если &afShowResultOnRun=`0`, будет показана только форма фильтрации.

&hideImpossible - при работе фильтра можно скрывать "невозможные" комбинации опций. Для этого нужно установить &hideImpossible=`1`. По умолчанию &hideImpossible=`0`.

&saveState - нужно ли сохранять значения фильтров, если пользователь уходил со страницы с формой. По умолчанию &saveState=`0`, состояние фильтров не будет сохраняться. Для принудительного сброса состояния фильтров необходимо прислать запрос с переменной, указанной в &resetStateKey

&resetStateKey - переменная в HTTP-запросе, при наличии которой будет сброшено состояние фильтров в сессии. По умолчанию &resetStateKey=`Reset`, т.е. где-то в форме должна быть кнопка вида <input type="submit" name="Reset" value="Сбросить фильтр" /> При нажатии этой кнопки фильтры сбросятся в начальное значение. Если &saveState=`0`  параметр &resetStateKey указывать нет смысла.

&saveStateKey - переменная в HTTP-запросе, при наличии которой будет сохраняться в сессию состояние фильтров. Используется, например, для сохранения состояния при пагинации. При наличии &saveState=`1` параметр &saveStateKey можно не указывать. По умолчанию &saveStateKey=`start`. Варианты использования для Ditto-пагинации: &afsaveStateKey=`start` или &saveStateKey=`ditto-id_start`.

&delim - разделитель в строке результатов фильтрования. По умолчанию - запятая.

&parseTpl - имя чанка,в котором осуществляется вызов сниппета для вывода значений. Подробнее см. описание для &return=`ids`. По умолчанию - пусто.


&customFilter - имя сниппета с пользовательскими фильтрами. Описание см. ниже. По умолчанию &customFilter=``.


********************************************************
_Плейсхолдеры в чанке формы фильтрации_
********************************************************
[+af.id+] - уникальный id вызова сниппета.

[ ! ] (обязательно использовать)В форме фильтрации обязательно нужно указать такую строку:
  <input type="hidden" name="afid" value="[+af.id+]" /> Без этого элемента форма обрабатываться не будет.




********************************************************
_Плейсхолдеры в результате (глобальные)_
********************************************************

[+af.items+] - строка с отфильтрованными id элементов каталога (товаров, документов), разделенными &delim (по умолчанию - запятая); может использоваться для подстановки в другие сниппеты
[+af.items_count+] - общее количество товаров/элементов
[+af.items_show_count+] - количество отфильтрованных элементов/товаров

Строка "Найдены N товаров из NN" таким образом реализуется шаблоном "Найдены [+af.items_show_count+] товаров из [+af.items_count+]"

[+af.form+] - при выводе формы из чанка, вместо этого плейсхолдера будет подставлен код самой формы
[+af.result+] - вывод либо из вложенного сниппета (Ditto), либо строки с id товаров

********************************************************
_Элементы форм и их генерация_
********************************************************

Каждая опция товара (э.к.) может использоваться для фильтрации несколькими способами. Первый способ: простая проверка на "установленность" опции. Используется для проверки на заполненность TV, или для каких-то других целей. Фильтр такого типа в дальнейшем будет называться "да-нет".

Второй способ - проверка на соответствие одному или нескольким значениям из списка. Используется для опций, у которых есть несколько значений и нужно выбрать товары (э.к.), у которых данная опция имеет то или иное значение. Выглядеть в форме это может как список, набор чекбоксов или радиокнопок (если нужно выбирать всегда 1 вариант). Фильтр этого типа в дальнейшем будет называться "точное соответствие".

Третий способ - задание каких-либо диапазонов значений. Выглядит либо как 2 текстовых поля, либо как разновидность слайдера с двумя ползунками. Название фильтра "от-до".

[ ! ] Здесь не рассматривается вариант, когда диапазоны жестко заданы и нужно фильтровать по вхождению в диапазон. Задача реализуемая, но встроенной возможности делать это не планируется.

Независимо от типа фильтра, необходимо иметь возможность генерировать определенные элементы формы с помощью шаблонов. Некоторые из этих шаблонов являются встроенными и могут использоваться простым указанием соответствующего плейсхолдера в чанке формы. Другие шаблоны необходимо будет создавать "вручную", причем также "вручную" нужно будет создавать для них обработчик.

Встроенные шаблоны используются следующих видов.

Оформление элементов формы в данной версии привязано к следующему виду.

1) Фильтр "да-нет". В форме будет сгенерирован такой код:

    <input type="checkbox" name="optNN_isset" value="checked" [+optNN_checked+] />
или, если в конфигурационном файле есть псевдоним для данной опции:
    <input type="checkbox" name="ALIAS_isset" value="checked" [+ALIAS_checked+] />

Плейсхолдер: [+af.optNN_isset+] или [+af.ALIAS_isset+], будет содержать HTML код инпута.

2) Фильтр "точное соответствие". Поскольку вариантов этого типа несколько, то будут сгенерированы несколько плейсхолдеров. Подставить в форму можно любой из них.

П: [+af.optNN_select+] или [+af.ALIAS_select+]
Код: см. файл formTemplates.inc.php

П: [+af.optNN_mselect+] или [+af.ALIAS_mselect+]
Код: см. файл formTemplates.inc.php

П: [+af.optNN_radio+] или [+af.ALIAS_radio+]
Код: см. файл formTemplates.inc.php

П: [+af.optNN_checkboxes+] или [+af.ALIAS_checkboxes+]
Код: см. файл formTemplates.inc.php


3) Фильтр "от-до". Поскольку стандартного ползунка с двумя указателями не существует, будет реализован код с использованием jQuery UI. 

/*П:  [+af.optNN_minmax+] или [+af.ALIAS_minmax+]
**  
**[!] Если не включить вывод скриптов в заголовок страницы, ползунки работать не будут! Тем не менее, вы можете организовать ползунки каким-либо своим способом.
*/


********************************************************
_Свои функции обработки фильтров_
********************************************************

В общем случае для создания своего фильтра нужны 3 функции: для обработки шаблона, для обработки значений в HTTP-запросе и для выборки значений из карты опций.

Возможность реализовать свой фильтр в данной версии реализована путем использования хук-функций. Их 3 типа: ИМЯ_parser, ИМЯ_request и ИМЯ_filter. ИМЯ_ - префикс, который задает наименование фильтра.

Все эти функции должны определяться в одном сниппете (см. &customFilter). Сниппет должен возвращать сериализованный массив с шаблонами пользовательских фильтров.
[!] Ключи массива будут определять названия фильтров.
[!] Если не вернуть из сниппета сериализованный массив с шаблоном или шаблонами, то пользовательские фильтры работать не будут.

[?]Пример создания собственного фильтра.

Предположим, что у нас есть опция, которая является строкой. Нам нужен фильтр, который будет пропускать только те товары, у которых строка будет определенной длины.

Назовем свой фильтр, например, 'my'. Чтобы подключить его, создадим сниппет в modx, назовем его "customFilter" (название - любое). В этом сниппете должны быть следующие разделы.

1) Раздел с шаблонами (если будет определяться несколько фильтров). В шаблоне нужно указать код элемента формы. В нашем примере это будет выглядеть так:

  $tpl['my'] = <<<CODE
    Длина строки <input type="text" name="[+name+]_my" value="[+my+]" /><br/>
CODE;

    ключ массива - my, он будет использоваться для идентификации фильтра.

2) Раздел с функциями. Для каждого шаблона нужно задать по 3 функции (см. выше).

Первая функция определяет, как будут использоваться параметры HTML-запроса. Название этой функции должно быть в виде ИМЯ_request. Параметры эта функция всегда получает такие:

  &$opt - ссылка на объект OptionMap (описание - ниже)
  $key  - строка вида либо optNN (где NN - или id опции, или название поля товара, как 'parent'), либо ALIAS (подставляется из файла конфигурации)

[!] Обратите внимание, что мы обрабатываем в функции именно ту переменную запроса, которую указали в шаблоне элемента формы. В шаблоне - name="[+name+]_my", в запросе - $_REQUEST[$key.'_my']

  function my_request(&$opt, $key) {
    $filterAr = array();

    if (isset($_REQUEST[$key.'_my'])
        && trim($_REQUEST[$key.'_my']) != ''
        && !is_array($_REQUEST[$key.'_my'])) {

      $filterAr[$key.'_my'] = $_REQUEST[$key.'_my'];
    }
    return $filterAr;
  }

[!] Функция должна возвратить массив. В обычных случаях, достаточно кода, приведенного выше.

Вторая функция используется для заполнения плейсхолдеров в шаблоне элемента формы. Ее название ИМЯ_parser. Параметры в нее передаются такие:

  &$opt - ссылка на объект OptionMap (описание - ниже)
  $code - тут будет передан тот самый код, который был указан в массиве $tpl['ИМЯ']
  $optId - в этом параметре будет содержаться id опции, который можно использовать для подстановки в форму
  $filterVal - в этой переменной хранится значение, полученное для данной опции из HTTP-запроса. Используется, например, для указания выбранного элемента списка select.

  function my_parser(&$opt, $code, $optId, $filterVal) {
    $retCode = '';

    //этот кусок служит для проверки, есть ли для данной опции алиас в файле конфигурации
    if (isset($opt->param['fields']['opt'.$optId])) {
      $optName = $opt->param['fields']['opt'.$optId];
    } else {
      $optName = 'opt'.$optId;
    }

    //тут задаются значения для плейсхолдеров в шаблоне
    $ph['name'] = $optName;
    $ph['my'] = $filterVal;

    //подстановка значений
    $retCode.= $opt->parser->parseTpl(array_keys($ph), array_values($ph), $code);
    return $retCode;
  }

[!] Функция должна возвратить полностью готовый html код. Этот код будет подставлен в глобальный плейсхолдер вида [+af.optNN_my+] или [+af.ALIAS_my+]

Третья функция используется непосредственно для отбора товаров из всего списка. Вы сами задаете логику фильтрации, исходя из значений опции и сопоставленных этому значению id товаров. Название функции ИМЯ_filter. Параметры:

  &$opt - ссылка на объект OptionMap (описание - ниже)
  $optId - в этом параметре будет содержаться id опции
  $filterVal - в этой переменной хранится значение, полученное для данной опции из HTTP-запроса.

  function my_filter(&$opt, $optId, $filterVal) {
    $retIdsAr = array();
    if (is_array($filterVal)) {
      //смысла не имеет, выход
      return $retIdsAr;
    }
    //выбираем все значения опции и сопоставленные документы
    if (is_array($opt->map[$optId])) {
      foreach ($opt->map[$optId] as $optVal => $docsAr) {
        if (strlen($optVal) == $filterVal) {
          $retIdsAr = array_merge($retIdsAr, $docsAr);
        }
      }
    }
    $retIdsAr = array_unique($retIdsAr);
    return $retIdsAr;
  }

[!] Функция должна возвратить массив с отфильтрованными id товаров (именно по данному фильтру).


3) Последнее, что должен делать сниппет - вернуть шаблон. По некоторым причинам, единственный способ это сделать следующий:

return serialize($tpl);

Осталось сохранить полученный сниппет и добавить в вызов параметр &customFilter=`customFilter`. Теперь при обработке фильтров сниппет autoFilter автоматически вызовет созданный сниппет customFilter и обработает данные созданного фильтра.


********************************************************
_Объект OptionMap_
********************************************************

Вкратце, данный объект при создании формирует несколько массивов с данными для фильтров. Главный из этих массивов - map. Его структура следующая:

$opt->map = array(
  option1 => array(
    value1 => array(
      item1, item2, item3....
    ),
    value2 => array(
      item1, item2, item3....
    ),...
  ),
  option2 => array(
    value1 => array(
      item1, item2, item3....
    ),
    value2 => array(
      item1, item2, item3....
    ),...
  ),...
)

(реальный пример приведен ниже)

Здесь:
  optionN - ID опции (берется из таблицы в БД) В случае базового функционала - это либо TV ID, либо название одного из полей документа (реализованы только parent и template). При работе сниппета autoFilter это название используется для именования полей в виде optN и для создания своих названий в файле конфигурации, в виде optN=ALIAS.

  valueN - значение опции. В массиве optionN содержатся все значения данной опции, которые встречаются в БД.

  itemN - id товара (элемента каталога). В массиве valueN содержатся все товары, у которых данная опция имеет данное значение.


Вторым массивом является вспомагательный массив options. В нем перечислены характеристики каждой опции. Эти характеристики можно использовать при создании шаблонов элементов формы.

Третий массив - items. Он практически не используется, в будущих версиях может быть удален.

Важным также является массив param. В нем содержатся, в частности все алиасы полей формы в виде $opt->param['fields']['optNN'].



********************************************************
_Проблемы кеширования_
********************************************************

Кеширование карты свойств необходимо по 2м причинам. Первая - ускорение работы, за счет сокращения количества генераций карты свойств. Вторая - в случае нескольких вызовов сниппета на странице нет необходимости создавать второй объект с картой.

Тем не менее, некоторые свойства объекта будут зависеть от того, с каким id вызван сниппет. Поэтому нельзя просто обеспечить Singleton для объекта OptionsMap.

Схема работы такая. При запуске сниппета мы проверяем кеш на наличие сохраненного объекта. Если его там нет, создаем. Если есть - "разворачиваем". В полученном объекте проверяем наличие ключей фильтров для данного id вызова. Если нет, создаем ключи и связанные с ними функции и шаблоны. Дальнейшая работа сниппета описана выше.

********************************************************
_Объект OptionMap из реальной жизни_
********************************************************

OptionsMapBase Object
(
    [items] => Array
        (
            [16] => Array
                (
                    [1] => 789
                    [pagetitle] => Стр1
                    [longtitle] =>
                    [template] => 4
                    [ptitle] =>
                    [parent] => 15
                    [2] => 1616
                    [4] => 4
                )

            [17] => Array
                (
                    [2] => 1717
                    [pagetitle] => Стр2
                    [longtitle] =>
                    [template] => 4
                    [ptitle] =>
                    [parent] => 15
                    [4] => 3
                )
                .........
    [options] => Array
        (
            [1] => Array
                (
                    [caption] => Просто TV
                    [elements] =>
                    [type] => text
                    [name] => test
                )

            [parent] => Array
                (
                    [caption] => Категория
                    [name] => parent
                )

            [2] => Array
                (
                    [caption] => Цена
                    [elements] =>
                    [type] => text
                    [name] => price
                )

            [4] => Array
                (
                    [caption] => select
                    [elements] => opt1==1||opt2==2||opt3==3||opt4==4
                    [type] => dropdown
                    [name] => list
                )

            [3] => Array
                (
                    [caption] => Да
                    [elements] => ==1
                    [type] => checkbox
                    [name] => isset
                )

        )
        .......
    [map] => Array
        (
            [1] => Array
                (
                    [789] => Array
                        (
                            [0] => 16
                        )

                    [55] => Array
                        (
                            [0] => 18
                        )

                )

            [parent] => Array
                (
                    [15] => Array
                        (
                            [0] => 16
                            [1] => 16
                            [2] => 16
                            [3] => 17
                            [4] => 17
                            [5] => 18
                            [6] => 18
                            [7] => 18
                            [8] => 18
                        )

                )

            [template] => Array
                (
                    [4] => Array
                        (
                            [0] => 16
                            [1] => 16
                            [2] => 16
                            [3] => 17
                            [4] => 17
                            [5] => 18
                            [6] => 18
                            [7] => 18
                            [8] => 18
                        )

                )

            [2] => Array
                (
                    [1616] => Array
                        (
                            [0] => 16
                        )

                    [1717] => Array
                        (
                            [0] => 17
                        )

                    [1818] => Array
                        (
                            [0] => 18
                        )

                )
.......
)
